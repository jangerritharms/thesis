\chapter{Problem description}
In the introduction we make a case for the decentralization of applications that handle private
information or resources and argues that scalability is one of the main problems of the promising
blockchain technology to make such systems a reality. Trustchain is an approach that removes the 
main bottleneck that restricts the scalability of the most common blockchain fabrics, namely global
consensus. However the lack of agreement on a single accepted set of transactions has many 
implications for attack resistance and correctness guarantess of the system. This chapter 
introduces these implications and defines the problem that this work is supposed to tackle.

\section{Attacks}

\subsection{Double-spend attack}
One of the most challenging attacks that exist in distributed systems is the \textit{double-spend}
attack in which an adversary creates two conflicting transactions with two different agents without
telling each about the other, effectively using resources twice. In centralized systems this attack
is prevented by the central server which processed transactions in order and realizes that the 
resources were spent in the first version of the transaction. Bitcoin was the first decentralized
accounting system that solved this problem without a central, trusted entity. However the mining
which creates a single accepted sequence for transactions is costly in terms of time and resources.
Without global consensus Trustchain (discussed in more detail in section 3) is not able to prevent 
the double-spend attack. Instead, the double-spend attack will be recorded and therefore made 
detectable. The attacker sends two conflicting transactions to two different agents and keeps one,
but both partners write the conflicting blocks on their chains. If those two agents share their 
blocks with each other or both share their blocks with a third agent, the attack becomes detectable
because the two blocks are conflicting. The prevention of this attack therefore requires 
dissemination of transaction data across the network and constant checking for conflicting 
transactions by all agents.

\subsection{Sybil attack}
During a sybil attack an adversary takes control over many entities at the same time without making
this known to the network. The attacker can then use those entities to gain influence without any
real cost because the controlled entities can create proof of transactions without actually 
performing them.

This problem is very hard to detect because controlled entities can look like real agents to 
external observers. In centralized systems this is often prevented by requiring multiple 
authentication steps, for example scanning an identity card. Also if the creation of new agents has
some costs, the adversary needs to evaluate the possible advantage against the cost of creating
multiple agents.
In Bitcoin and other proof-of-work based cryptocurrencies the attack is avoided because the power
to create a new block is proportional to computational power, so whether the computational power
is spread over multiple agents or not does not matter to the voting power in the system.

For other decentralized systems the sybil attack continues to be a challenging problem. Many 
solutions have been proposed which analyze the topology of the network. Also an initial negative 
balance has been proposed by some. Specifically for the Trustchain two algorithms, namely NetFlow
and Temporal PageRank. Yet, while the two algorithms allow for sybil-resistant calculation of a 
metric which is related to the balance of agents. Also the accuracy of the algorithms depends on 
the amount of data that is available, making it neccessary to share data between agents in order
to better be able to estimate the probability of sybils. The sybil attack will further be discussed
in chapter 4.

\subsection{Blockwithholding attack}
In decentralized systems it can be advantageous for agents to not share some information about
their transactions that would otherwise render them in a weaker position. This is not possible
in centralized systems because users do not keep their own data which instead is stored on the
central server. Thus it is not the user's decision to share or not share information with others.

In common blockchain fabrics all information is shared with everyone and only information that is 
accepted by everyone is true. By removing the global consensus this guarantee is no longer intact.
If user's own their data, they can decide to share it or not. Agents can claim that information was
lost during transactions or that a transaction did not take place.

\subsection{Dishonest behaviour}
Some application types may require agents to act according to a specific set of rules. For example
in the Tribler application, if an agent (responder) receives two requests for contribution the 
agent should contribute to the one agent that has contributed the most in the past as that agent 
deserves to be rewarded for those past contributions. Without global consensus the agent determines
the ``goodness'' of the requesters on the basis of an unobserved information set, which is a subset
of the global network information. However the agent can also decide to not stick to the rules and
contribute to the lesser of the two requesters. Without consensus on the information set on the 
basis of which the responder decides, this dishonest behaviour cannot be detected and punished by
other agents.

\section{Research question}
From the above discussion it becomes clear that removing the global consensus from any blockchain
farbics opens the system to many forms of attacks. The missing guarantees on information makes it
hard to check the correct behaviour of other agents. This makes sharing of information and 
validation of transactions an essential building block of a blockchain system without global
consensus. Yet, the question is how to enforce dissemination of transaction records without a
trusted third party. Also which information is neccessary to distribute accross the network and how
can we make sure that validation of that information is done by all nodes. Formally we can define 
the following research question:

\begin{center}
    \textit{How can we design a scalable, decentralized accounting system that ensures the distribution,
    correctness and honest usage of transaction records?}
\end{center}

The research question entails some requirements for the system that we are trying to develop. In 
the following we will explain each of those in more detail.


\subsection{Accounting system}
\label{sec:accounting_system}
The system we are trying to build is an accounting system. An accounting system keeps track of 
transactions of a resource of value between at least two parties. Accounting systems have many 
applications; two common examples are a banking system and a reputation system. Each entity in 
the accounting system has a unique identifier and from the history of the transactions recorded 
in the system a certain balance can be assigned to each identifier. When a new transaction is issued 
the balance is increased or decreased and usually some threshold is put inplace to restrict the 
infinite spending of resources. This implies that the order of transactions is of importance. As an 
example consider an entity A with the balance of 5 a minimum threshold of 0 and two transaction 
spending 4 units and 3 units two parties B and C, respectively. Obviously, it is not possible that
both transactions are accepted. Either, A first spends 4 units on the interaction with B and cannot
afford the transaction with C or the other way around. If entity A tries to submit both transactions
at the exact same time, it is the task of the accounting system to create an order of two transactions
and restrict the expenditure beyond the balance threshold.

\subsection{Scalability}
Accounting systems can exist in many different sizes and contexts, they do not even have to be
digital for some applications. However in this work we are concerned with planet-scale accounting
which even enables micro-transactions with high frequency. Therefore scalability is one of the 
main factors. Before the ascent of internet applications such dimensions were unheard of but in
the last decade services such as Facebook, WeChat or YouTube have shown that an application can 
grow to have billions of users. Our ambition is to lay the theoretical and practical basis for 
future systems that scale to these sizes. In practice that means that the transaction throughput
of the global systems needs to grow with the amount of users and that no global limit is in place
that restricts further growth.

\subsection{Decentralization}
Ownership of all transaction data can, depending on the context, give the owner power, leverage and 
value. Furthermore, a central entity creates a target for attackers and with sufficient resources
available an adversary will in the end be able to compromise the system. We see accounting systems
as a part of the infrastructure that enables applications such as banking or reputation systems. No 
single entity should be owner of such infrastructure. That is why we are considering a decentralized
solution. In the context of an internet application a centralized model assumes that one single (central)
trusted entity has access to all information and all users know and connect to that single entity. In a 
decentralized model, we cannot assume that any other entity is trustworthy or omniscent. Instead entities
are equal and communicate with each other. All users know about their own transactions and are owner of
their data, with full control over whom to share them with. 

\subsection{Distribution}
In a perfectly decentralized system each entity only knows about their own transactions. For an 
accounting system that means that each entity needs to check for themselves that they do not exceed the
balance threshold. Yet, an entity's interest could be to spend as much as possbile, which makes the 
self-control mechanism ineffective. In the context of reputation systems, an entity's interest could be
to show their good behaviour to others. In those situations a distribution mechanism needs to be put 
inplace because in a decentralized system we can no longer assume that information is simply available from
the central entity. Perfect distribution of data would mean that each user is informed about each transaction
happening on the accounting system's network. However in practice such a situation virtually impossible to 
uphold, especially when scaling to global high-frequency microtransactions. A balance needs to be found 
between the distribution of information, the scalability of the system and the storage and processing 
capabilities of each entity.

\subsection{Correctness}
In order to ensure the correctness of data multiple aspects need to be considered. First of all data needs
to be stored in a tamper-proof manner, that is, once a transaction is accepted by all parties that transaction
should not be changeable afterwards. Also the order of transactions needs to be definite, the reason for 
this was explained in Section \ref{sec:accounting_system}. Finally, entities need to be able to validate the
correctness of the state of the system.
The distribution of data informs entities in the system about the behaviour of other agents, but without
validation of that data, missing or wrong information cannot be found. This is another aspect that is often
solved by a central entity that continuously analyzes the information received by users. In a decentralized
system the validation has to be performed by each entity. For example entity A has a balance of 2 units but
is trying to spend 3 units in a transaction to entity B. Without a central entity the only party to
prevent A from transaction is entity B. B is only able to detect the invalid transaction if A has shared all
it's transactions with B and if B uses some validation precedure before engaging in a new transaction. It is
important to realize that validation is only possible if information is distributed. 

\subsection{Honest usage}
Finally, the system should make it possible to ensure the honest behaviour of entities. To show how the 
previous two components are not enough to ensure this, we can continue with the example from the previous
section. So even if B knows that the balance of A is insufficient to commit the transaction, both could 
collude and still commit the transaction. Afterwards, there is no way of knowing whether B was acting 
wrong on purpose or whether A did not share its information correctly. 

In order to ensure correct usage of the given information it needs to be possible to distinguish good from
bad behaviour. Without a central entity that knows the truth about every entity it is not straightforward to 
know which entity is the responsible one for a wrong transaction.


\section{Limitations and assumptions}